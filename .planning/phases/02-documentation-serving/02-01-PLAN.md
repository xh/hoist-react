---
phase: 02-documentation-serving
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp/util/paths.ts
  - mcp/data/doc-registry.ts
autonomous: true

must_haves:
  truths:
    - "Document registry enumerates all ~30 hoist-react docs with correct file paths, IDs, categories, and metadata"
    - "Search function finds relevant documents by keyword across both metadata and file content"
    - "Path resolution safely prevents traversal outside the repo root"
  artifacts:
    - path: "mcp/util/paths.ts"
      provides: "Repo root resolution and path traversal protection"
      exports: ["resolveRepoRoot", "resolveDocPath"]
    - path: "mcp/data/doc-registry.ts"
      provides: "Document inventory, metadata, file loading, and keyword search"
      exports: ["DocEntry", "DocCategory", "SearchResult", "buildRegistry", "loadDocContent", "searchDocs"]
  key_links:
    - from: "mcp/data/doc-registry.ts"
      to: "mcp/util/paths.ts"
      via: "import resolveRepoRoot, resolveDocPath"
      pattern: "import.*from.*paths"
    - from: "mcp/data/doc-registry.ts"
      to: "docs/README.md, AGENTS.md, */README.md, docs/*.md"
      via: "readFileSync with resolved paths"
      pattern: "readFileSync"
---

<objective>
Build the document registry data layer and path utilities that underpin all Phase 2 MCP resources and tools.

Purpose: The registry is the single source of truth for what documentation exists, where it lives, and how to search it. Both MCP resources and tools (Plan 02) consume this data layer.

Output: Two modules -- `mcp/util/paths.ts` (repo root resolution, path safety) and `mcp/data/doc-registry.ts` (document inventory, metadata, file loading, keyword search).
</objective>

<execution_context>
@/Users/amcclain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amcclain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-documentation-serving/02-RESEARCH.md
@.planning/phases/01-mcp-server-foundation/01-02-SUMMARY.md

Source files to understand existing patterns:
@mcp/util/logger.ts
@mcp/server.ts
@docs/README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create path utilities for repo root resolution and path safety</name>
  <files>mcp/util/paths.ts</files>
  <action>
Create `mcp/util/paths.ts` with two exported functions:

1. **`resolveRepoRoot(): string`**
   - Uses `import.meta.url` with `fileURLToPath` from `node:url` to get this file's absolute path.
   - Walks up from `mcp/util/paths.ts` -> `mcp/util/` -> `mcp/` -> repo root (i.e., `path.resolve(dirname, '..', '..')`).
   - Sanity check: verify `AGENTS.md` exists at the resolved root. If not, throw a descriptive error.
   - Returns the resolved absolute path string.
   - Cache the result in a module-level variable so repeated calls don't re-resolve.

2. **`resolveDocPath(repoRoot: string, relativePath: string): string`**
   - Uses `path.resolve(repoRoot, relativePath)` to get the absolute path.
   - **Security check:** Verify the resolved path starts with `repoRoot + path.sep` (or equals `repoRoot`). If not, throw `Error('Path traversal detected: ...')`.
   - Reject any `relativePath` containing `..` segments as an additional guard.
   - Returns the validated absolute path.

Use imports from `node:fs` (`existsSync`), `node:path` (`resolve`, `dirname`), and `node:url` (`fileURLToPath`).

Follow the same code style as `mcp/util/logger.ts` -- clean, documented, no classes.
  </action>
  <verify>
Run `npx tsc --project mcp/tsconfig.json --noEmit` -- should pass with no errors.

Manually verify the logic: `resolveRepoRoot()` should find the repo root 2 directories up from the file. `resolveDocPath` should reject paths with `..`.
  </verify>
  <done>
`mcp/util/paths.ts` exists, exports `resolveRepoRoot` and `resolveDocPath`, type-checks cleanly, and protects against path traversal.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create document registry with inventory, metadata, loading, and search</name>
  <files>mcp/data/doc-registry.ts</files>
  <action>
COMPLETE SPECIFICATION FOLLOWS -- implement exactly as specified below, including all types, all registry entries, all functions, and the search algorithm.

Create `mcp/data/doc-registry.ts` exporting the following types and functions:

**Types:**

```typescript
type DocCategory = 'package' | 'concept' | 'devops' | 'conventions' | 'index';

interface DocEntry {
    /** Unique identifier, e.g. 'core', 'cmp/grid', 'lifecycle-app', 'conventions' */
    id: string;
    /** Display title, e.g. 'Core Framework', 'Grid Component' */
    title: string;
    /** Absolute file path on disk */
    filePath: string;
    /** Category for filtering */
    category: DocCategory;
    /** Package name if category is 'package', e.g. 'core', 'cmp/grid' */
    packageName?: string;
    /** Short description from the docs index */
    description: string;
    /** Key topics/keywords for search matching */
    keywords: string[];
}

interface SearchResult {
    entry: DocEntry;
    /** Lines containing matches, with 1-based line numbers */
    snippets: Array<{lineNumber: number; text: string}>;
    /** Total keyword match count (metadata + content) */
    matchCount: number;
}

interface SearchOptions {
    category?: DocCategory | 'all';
    limit?: number;
}
```

**`buildRegistry(repoRoot: string): DocEntry[]`**

Build the complete document inventory. This is a **hardcoded registry** -- not a filesystem scan -- because the documentation structure is well-known and stable. Each entry has metadata derived from the docs/README.md index.

Include these documents (verified file paths from the actual repo):

**Static entries (category: 'index' and 'conventions'):**
- id: `index`, title: `Hoist Documentation Index`, file: `docs/README.md`, category: `index`
- id: `conventions`, title: `Hoist Coding Conventions`, file: `AGENTS.md`, category: `conventions`

**Package READMEs (category: 'package'):**
Build entries for each of these packages. The `id` equals the package path (relative to repo root, without `/README.md`). The `title`, `description`, and `keywords` come from the docs/README.md tables:

- `core` -- Foundation classes (HoistBase, HoistModel, HoistService, hoistCmp, XH, element factories, decorators, lifecycle)
- `data` -- Observable data layer (Store, StoreRecord, Field, Filter, Cube, View, tree data, loadData, processRawData)
- `svc` -- Built-in singleton services (FetchService, ConfigService, PrefService, IdentityService, TrackService, WebSocketService)
- `cmp` -- Cross-platform component overview (Component categories, factory pattern, platform-specific vs shared)
- `cmp/grid` -- Primary data grid (GridModel, Column, ColumnGroup, sorting, grouping, filtering, selection, inline editing, export)
- `cmp/form` -- Form infrastructure (FormModel, FieldModel, SubformsFieldModel, validation rules, data binding)
- `cmp/input` -- Input base classes (HoistInputModel, change/commit lifecycle, value binding, focus management)
- `cmp/layout` -- Flexbox layout containers (Box, VBox, HBox, Frame, Viewport, LayoutProps, pixel conversion)
- `cmp/tab` -- Tabbed interface (TabContainerModel, routing integration, render modes, refresh strategies)
- `cmp/viewmanager` -- View manager (ViewManagerModel, views, sharing, pinning, auto-save, JsonBlob persistence)
- `desktop/cmp/dash` -- Dashboard system (DashContainerModel, DashCanvasModel, DashViewSpec, DashViewModel, widget persistence, ViewManager integration)
- `desktop/cmp/panel` -- Desktop panel (Panel, PanelModel, Toolbar, mask, collapse/resize, persistence, modal support)
- `desktop` -- Desktop-specific components
- `mobile` -- Mobile components (AppContainer, NavigatorModel, Panel, AppBar, mobile inputs, touch navigation, swipeable tabs)
- `format` -- Formatting (fmtNumber, fmtPercent, fmtMillions, numberRenderer, dateRenderer, ledger, colorSpec, auto-precision)
- `appcontainer` -- App shell (AppContainerModel, MessageSpec, ToastSpec, BannerSpec, ExceptionDialogModel, ThemeModel, RouterModel, AppOption)
- `utils` -- Utilities (Timer, LocalDate, forEachAsync, decorators, logging, hooks)
- `promise` -- Promise extensions (catchDefault, catchWhen, track, linkTo, timeout, thenAction, wait, waitFor, tap)
- `mobx` -- MobX integration (@bindable, @bindable.ref, makeObservable, observer, action, observable, computed, enforceActions)
- `public` -- Public resources
- `static` -- Static assets

For each, `filePath` = `resolveDocPath(repoRoot, '{id}/README.md')`. Keywords should be split from the comma-separated Key Topics in the docs index.

**Concept docs (category: 'concept'):**
- `lifecycle-app` -- file: `docs/lifecycle-app.md`, keywords from docs index
- `lifecycle-models-and-services` -- file: `docs/lifecycle-models-and-services.md`
- `authentication` -- file: `docs/authentication.md`
- `persistence` -- file: `docs/persistence.md`

**DevOps docs (category: 'devops'):**
- `build-and-deploy` -- file: `docs/build-and-deploy.md`
- `development-environment` -- file: `docs/development-environment.md`
- `compilation-notes` -- file: `docs/compilation-notes.md`
- `changelog-format` -- file: `docs/changelog-format.md`

Validate that each file exists at startup using `existsSync`. Log a warning (via the stderr logger) for any missing files but do NOT throw -- just skip them from the registry.

Import `resolveDocPath` from `../util/paths.js` for path construction. Import `log` from `../util/logger.js` for warnings.

**`loadDocContent(entry: DocEntry): string`**

Read and return the file content using `readFileSync(entry.filePath, 'utf-8')`. Throw a clear error if the file doesn't exist (should not happen if registry validated at build time, but be safe).

**`searchDocs(registry: DocEntry[], query: string, options?: SearchOptions): SearchResult[]`**

Search implementation:
1. Split query into lowercase terms (split on whitespace, filter out terms with length <= 1).
2. For each registry entry:
   a. If `options.category` is set and not `'all'`, skip entries that don't match.
   b. Build metadata text from `title + description + keywords.join(' ')`, lowercase.
   c. Count metadata term matches.
   d. Read file content via `readFileSync`.
   e. Count content term matches (how many search terms appear in the lowercased content).
   f. If zero total matches, skip.
   g. Extract up to 5 snippet lines containing any search term (line number + trimmed text, cap each line at 200 chars).
3. Sort results by `matchCount` descending.
4. Slice to `options.limit ?? 10`.
5. Return the `SearchResult[]`.

This is simple string matching -- no libraries needed for ~30 files / ~482KB.
  </action>
  <verify>
Run `npx tsc --project mcp/tsconfig.json --noEmit` -- should pass with no errors.

Verify the registry covers the expected document count: approximately 30 entries across all categories.
  </verify>
  <done>
`mcp/data/doc-registry.ts` exists, exports all types and functions, type-checks cleanly, and provides a complete inventory of hoist-react documentation with search capability.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --project mcp/tsconfig.json --noEmit` passes cleanly
2. Both files exist at expected paths (`mcp/util/paths.ts`, `mcp/data/doc-registry.ts`)
3. Exported types and functions match the specification
4. No `console.log` anywhere -- only `log` from logger.ts or `readFileSync`/`existsSync` from node:fs
</verification>

<success_criteria>
- Document registry can enumerate all ~30 hoist-react docs with correct metadata
- Search function finds relevant documents by keyword
- Path utilities prevent traversal attacks
- All code type-checks cleanly under mcp/tsconfig.json
- No stdout pollution (no console.log)
</success_criteria>

<output>
After completion, create `.planning/phases/02-documentation-serving/02-01-SUMMARY.md`
</output>
