---
phase: 03-typescript-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp/data/ts-registry.ts
autonomous: true

must_haves:
  truths:
    - "ts-morph Project is created lazily on first invocation, not at server startup"
    - "Symbol index (Map<string, SymbolEntry[]>) is built eagerly after Project creation using AST-level methods"
    - "Index covers classes, interfaces, type aliases, functions, and exported const variables from hoist-react source files"
    - "Barrel re-export files (index.ts) do not produce duplicate symbol entries"
    - "Detailed symbol info (type signatures, JSDoc, decorators) is extracted on-demand per query"
    - "Class/interface member listing includes properties, methods, their types, decorators, and JSDoc"
    - "Cold start (Project creation + index build) completes in under 5 seconds"
  artifacts:
    - path: "mcp/data/ts-registry.ts"
      provides: "ts-morph Project wrapper, lazy init, symbol index, search, detail extraction, member listing"
      exports: ["ensureInitialized", "searchSymbols", "getSymbolDetail", "getMembers"]
  key_links:
    - from: "mcp/data/ts-registry.ts"
      to: "tsconfig.json"
      via: "ts-morph Project tsConfigFilePath"
      pattern: "tsConfigFilePath.*tsconfig\\.json"
---

<objective>
Create the TypeScript symbol extraction data layer using ts-morph.

Purpose: This is the core data engine for Phase 3 -- it wraps ts-morph to parse hoist-react's
~703 TypeScript source files, builds a searchable symbol index, and provides on-demand extraction
of detailed type information. All three MCP tools (search-symbols, get-symbol, get-members) in
Plan 03-02 will consume this module's API.

Output: `mcp/data/ts-registry.ts` with lazy Project initialization, eager symbol indexing, symbol
search, detailed symbol extraction, and member listing.
</objective>

<execution_context>
@/Users/amcclain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amcclain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-typescript-extraction/03-RESEARCH.md

# Phase 2 patterns (data layer follows doc-registry.ts structure)
@mcp/data/doc-registry.ts
@mcp/util/paths.ts
@mcp/util/logger.ts

# Repo tsconfig (used by ts-morph Project)
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ts-registry with lazy Project init and eager symbol index</name>
  <files>mcp/data/ts-registry.ts</files>
  <action>
Create `mcp/data/ts-registry.ts` following the architecture from 03-RESEARCH.md. This file is the
TypeScript extraction data layer, analogous to `doc-registry.ts` for documentation.

**Types to define:**

```typescript
/** Kind of TypeScript symbol in the index. */
type SymbolKind = 'class' | 'interface' | 'type' | 'function' | 'const' | 'enum';

/** Lightweight index entry for fast search. */
interface SymbolEntry {
    name: string;
    kind: SymbolKind;
    filePath: string;         // Absolute path to declaration file
    isExported: boolean;
    sourcePackage: string;    // e.g. 'core', 'cmp/grid', 'data' -- derived from file path
}

/** Detailed symbol information extracted on-demand. */
interface SymbolDetail {
    name: string;
    kind: SymbolKind;
    filePath: string;
    sourcePackage: string;
    isExported: boolean;
    signature: string;        // Full type signature as clean TypeScript
    jsDoc: string;            // Combined JSDoc description
    extends?: string;         // Base class/interface name (for classes/interfaces)
    implements?: string[];    // Implemented interfaces (for classes)
    decorators?: string[];    // Class-level decorators
}

/** A member (property or method) of a class or interface. */
interface MemberInfo {
    name: string;
    kind: 'property' | 'method' | 'accessor';
    type: string;             // Type as TypeScript text
    isStatic: boolean;
    isOptional?: boolean;
    decorators: string[];     // e.g. ['observable', 'bindable']
    jsDoc: string;            // JSDoc description
    parameters?: Array<{name: string; type: string}>;  // For methods
    returnType?: string;      // For methods
}
```

**Lazy initialization pattern:**

- Module-level `let project: Project | null = null` and `let symbolIndex: Map<string, SymbolEntry[]> | null = null`
- Export `ensureInitialized()` function that:
  1. Returns immediately if already initialized (project !== null)
  2. Records `Date.now()` for timing
  3. Creates `new Project({ tsConfigFilePath: resolve(resolveRepoRoot(), 'tsconfig.json'), skipFileDependencyResolution: true })`
  4. Calls `project.resolveSourceFileDependencies()`
  5. Calls `buildSymbolIndex(project)` to populate `symbolIndex`
  6. Logs initialization timing via `log.info`
  7. If timing exceeds 5000ms, log a warning

**Index building (`buildSymbolIndex`):**

- Iterate over `project.getSourceFiles()`
- **SKIP** files whose path includes `node_modules`, `/build/`, or `/mcp/`
- For each source file, extract:
  - Classes via `sourceFile.getClasses()` -- kind='class'
  - Interfaces via `sourceFile.getInterfaces()` -- kind='interface'
  - Type aliases via `sourceFile.getTypeAliases()` -- kind='type'
  - Functions via `sourceFile.getFunctions()` -- kind='function'
  - Enums via `sourceFile.getEnums()` -- kind='enum'
  - Exported const variables via `sourceFile.getVariableStatements()` -> filter `isExported()`,
    then iterate `getDeclarations()` -- kind='const'
- For each symbol: use `getName()` (skip if null/undefined), check `isExported()`,
  derive `sourcePackage` from the file path relative to repo root (e.g. file at
  `/repo/core/HoistBase.ts` -> package `core`; file at `/repo/cmp/grid/GridModel.ts` -> package `cmp/grid`)
- Key the index by **lowercase name** for case-insensitive search
- Do NOT use `getExportedDeclarations()` -- it triggers full type binding and is ~1000x slower
- Log index stats: total symbols, exported symbols, by kind

**sourcePackage derivation:**

```typescript
function derivePackage(filePath: string, repoRoot: string): string {
    const rel = filePath.slice(repoRoot.length + 1); // Remove repo root prefix
    // Known top-level packages
    const topLevel = ['core', 'data', 'svc', 'cmp', 'desktop', 'mobile', 'format',
                      'appcontainer', 'utils', 'promise', 'mobx', 'public', 'static',
                      'admin', 'inspector', 'icon'];
    const parts = rel.split('/');
    // Find the deepest package match: e.g. cmp/grid, desktop/cmp/dash
    // Return the path segments up to but not including the file name,
    // stopping when we hit a non-package segment
    if (topLevel.includes(parts[0])) {
        // For nested packages like cmp/grid, cmp/form, desktop/cmp/dash:
        // walk until we hit a .ts file or a non-directory segment
        const pkgParts = [parts[0]];
        for (let i = 1; i < parts.length - 1; i++) {
            if (!parts[i].includes('.')) pkgParts.push(parts[i]);
            else break;
        }
        return pkgParts.join('/');
    }
    return parts[0] || 'unknown';
}
```
Simplify this as appropriate -- the key is that `core/HoistBase.ts` -> `core` and
`cmp/grid/GridModel.ts` -> `cmp/grid`.

**Export these public API functions (implementations in Task 2):**
- `ensureInitialized(): void` -- lazy init, safe to call multiple times
- `searchSymbols(query: string, options?: {kind?: SymbolKind; exported?: boolean; limit?: number}): SymbolEntry[]`
- `getSymbolDetail(name: string, filePath?: string): SymbolDetail | null`
- `getMembers(name: string, filePath?: string): {symbol: SymbolDetail; members: MemberInfo[]} | null`

For this task, implement `ensureInitialized()` and `searchSymbols()`. Leave `getSymbolDetail()`
and `getMembers()` as stubs returning null (implemented in Task 2).
  </action>
  <verify>
Run `npx tsc --noEmit -p mcp/tsconfig.json` -- should pass with zero errors.
Verify that ts-morph is installed: `ls node_modules/ts-morph/package.json`.
If ts-morph is not installed, run `yarn add -D ts-morph` first.
  </verify>
  <done>
ts-registry.ts exists with SymbolEntry/SymbolDetail/MemberInfo types, lazy Project initialization
using repo root tsconfig.json, eager symbol index built via AST-level methods (not
getExportedDeclarations), case-insensitive search returning matching SymbolEntry arrays, and
stub signatures for getSymbolDetail and getMembers. Type-checks cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement on-demand detail extraction and member listing</name>
  <files>mcp/data/ts-registry.ts</files>
  <action>
Complete the `getSymbolDetail()` and `getMembers()` functions in `mcp/data/ts-registry.ts`.

**`getSymbolDetail(name, filePath?)`:**
1. Call `ensureInitialized()` to ensure the index exists
2. Find the symbol in the index by exact name match (case-sensitive). If `filePath` is provided,
   further filter to that specific file. If multiple matches and no filePath, return the first
   exported match (prefer exported over non-exported).
3. Use `project.getSourceFile(entry.filePath)` to get the source file
4. Find the declaration node by kind:
   - class: `sourceFile.getClass(name)`
   - interface: `sourceFile.getInterface(name)`
   - type: `sourceFile.getTypeAlias(name)`
   - function: `sourceFile.getFunction(name)`
   - enum: `sourceFile.getEnum(name)`
   - const: find via `getVariableDeclaration(name)` on the source file
5. Extract:
   - `signature`: For classes/interfaces, use the declaration's full text up to the opening brace
     (the "header"). For type aliases, use `getText()`. For functions, use the signature
     (return type + parameters) without the body. For consts, use the declaration text.
     Clean up to produce readable TypeScript.
   - `jsDoc`: Use `getJsDocs()` -> map to `getDescription()` -> join with newlines. Trim.
   - `extends`: For classes, `getExtends()?.getText()`. For interfaces, `getExtends()` array -> map getText -> join(', ').
   - `implements`: For classes, `getImplements()` -> map getText.
   - `decorators`: For classes, `getDecorators()` -> map getName.

**`getMembers(name, filePath?)`:**
1. Get the SymbolDetail via `getSymbolDetail(name, filePath)` -- return null if not found
2. Only classes and interfaces have members -- return null for other kinds
3. Find the declaration node (same as above)
4. For classes, extract:
   - Instance properties: `getInstanceProperties()` -> for each:
     - name, type via `getType().getText(prop)`, isStatic: false
     - decorators via `getDecorators()?.map(d => d.getName())` (use optional chaining -- not all
       property types support getDecorators)
     - jsDoc via `getJsDocs()`
     - kind: 'property' for PropertyDeclaration, 'accessor' for GetAccessorDeclaration
   - Static properties: `getStaticProperties()` -> same extraction, isStatic: true
   - Instance methods: `getInstanceMethods()` -> for each:
     - name, returnType via `getReturnType().getText(method)`
     - parameters via `getParameters()` -> map to {name, type}
     - decorators, jsDoc
     - kind: 'method', isStatic: false
   - Static methods: `getStaticMethods()` -> same, isStatic: true
5. For interfaces, extract:
   - Properties: `getProperties()` -> name, type, isOptional via `hasQuestionToken()`
   - Methods: `getMethods()` -> name, returnType, parameters
   - No decorators or static members for interfaces
6. Return `{symbol: symbolDetail, members: memberInfoArray}`

**Important implementation notes:**
- Use `try/catch` around `getType().getText()` calls -- some types may fail to resolve (e.g.
  circular references, complex generics). Fall back to `'unknown'` on error.
- For the `signature` field, keep it concise. For a class like `export class GridModel extends
  HoistModel`, just show that header line -- don't include the full class body.
- Decorators: use optional chaining (`node.getDecorators?.()`) because not all node types in
  ts-morph have getDecorators (e.g. ParameterDeclaration in some contexts).
- Log errors via `log.warn` for individual symbol extraction failures -- don't let one bad
  symbol crash the whole query.
  </action>
  <verify>
Run `npx tsc --noEmit -p mcp/tsconfig.json` -- should pass with zero errors.
  </verify>
  <done>
getSymbolDetail returns complete SymbolDetail (signature, JSDoc, extends, implements, decorators)
for any indexed symbol. getMembers returns full member listings for classes and interfaces
including property types, method signatures, decorator names, and JSDoc. Both handle errors
gracefully with fallback values. Type-checks cleanly.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit -p mcp/tsconfig.json` passes with zero errors
2. ts-registry.ts exports ensureInitialized, searchSymbols, getSymbolDetail, getMembers
3. No use of getExportedDeclarations() anywhere in the file
4. AST-level methods (getClasses, getInterfaces, getTypeAliases, getFunctions, getEnums, getVariableStatements) used for index building
5. Project uses repo root tsconfig.json (not mcp/tsconfig.json) for ts-morph
6. Index is keyed by lowercase name for case-insensitive search
</verification>

<success_criteria>
The TypeScript extraction data layer is complete and ready for MCP tool registration in Plan 03-02.
All public API functions (ensureInitialized, searchSymbols, getSymbolDetail, getMembers) are
implemented and type-check cleanly. The module follows the same data-layer pattern as doc-registry.ts.
</success_criteria>

<output>
After completion, create `.planning/phases/03-typescript-extraction/03-01-SUMMARY.md`
</output>
