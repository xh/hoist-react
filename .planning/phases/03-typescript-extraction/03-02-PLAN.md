---
phase: 03-typescript-extraction
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - mcp/tools/typescript.ts
  - mcp/server.ts
autonomous: true

must_haves:
  truths:
    - "LLM can search for a TypeScript symbol by name and get matching results with source locations"
    - "LLM can retrieve detailed type information for a specific symbol including signature, JSDoc, and file path"
    - "LLM can list all members of a class or interface with types, decorators, and descriptions"
    - "All three tools initialize ts-morph lazily on first invocation -- server startup is not affected"
    - "Tool output is formatted as readable text optimized for LLM consumption"
  artifacts:
    - path: "mcp/tools/typescript.ts"
      provides: "MCP tool registrations for hoist-search-symbols, hoist-get-symbol, hoist-get-members"
      exports: ["registerTsTools"]
    - path: "mcp/server.ts"
      provides: "Updated server entry point importing and calling registerTsTools"
  key_links:
    - from: "mcp/tools/typescript.ts"
      to: "mcp/data/ts-registry.ts"
      via: "import of searchSymbols, getSymbolDetail, getMembers"
      pattern: "import.*from.*ts-registry"
    - from: "mcp/server.ts"
      to: "mcp/tools/typescript.ts"
      via: "import and call registerTsTools"
      pattern: "registerTsTools\\(server\\)"
---

<objective>
Register three MCP tools for TypeScript symbol exploration and wire them into the server.

Purpose: These tools expose the ts-morph extraction pipeline (built in Plan 03-01) to LLMs via
the MCP protocol. With these tools, an LLM can search for framework symbols, inspect their type
signatures, and enumerate class/interface members -- enabling accurate, informed code generation.

Output: `mcp/tools/typescript.ts` with three tool registrations, updated `mcp/server.ts` with
TypeScript tool registration.
</objective>

<execution_context>
@/Users/amcclain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amcclain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-typescript-extraction/03-RESEARCH.md
@.planning/phases/03-typescript-extraction/03-01-SUMMARY.md

# Established tool registration pattern
@mcp/tools/docs.ts
@mcp/server.ts

# Data layer consumed by these tools
@mcp/data/ts-registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript tools module with three MCP tools</name>
  <files>mcp/tools/typescript.ts</files>
  <action>
Create `mcp/tools/typescript.ts` following the exact registration pattern from `mcp/tools/docs.ts`.

Export a single function: `registerTsTools(server: McpServer): void`

**Tool 1: hoist-search-symbols**

```typescript
server.registerTool(
    'hoist-search-symbols',
    {
        title: 'Search Hoist TypeScript Symbols',
        description: 'Search for TypeScript classes, interfaces, types, and functions across the hoist-react framework by name. Returns matching symbols with their kind, source file, and package. Use this to find symbols before getting detailed information.',
        inputSchema: z.object({
            query: z.string().describe('Symbol name or partial name to search for (e.g. "GridModel", "Store", "Panel")'),
            kind: z.enum(['class', 'interface', 'type', 'function', 'const', 'enum']).optional()
                .describe('Filter by symbol kind. Default: all kinds'),
            exported: z.boolean().optional()
                .describe('Filter to exported symbols only. Default: true'),
            limit: z.number().min(1).max(50).optional()
                .describe('Maximum results. Default: 20')
        }),
        annotations: {
            readOnlyHint: true,
            destructiveHint: false,
            idempotentHint: true,
            openWorldHint: false
        }
    },
    async ({query, kind, exported, limit}) => { ... }
);
```

Handler implementation:
1. Call `ensureInitialized()` (lazy init on first use)
2. Call `searchSymbols(query, {kind, exported: exported ?? true, limit: limit ?? 20})`
3. Format results as readable text:
   - Header: "Found N symbols matching 'query':"
   - For each result: `N. [kind] name (package: pkg, file: relative/path.ts, exported: yes/no)`
   - If no results: "No symbols found matching 'query'. Try a broader search term."

**Tool 2: hoist-get-symbol**

```typescript
server.registerTool(
    'hoist-get-symbol',
    {
        title: 'Get Hoist Symbol Details',
        description: 'Get detailed type information for a specific TypeScript symbol including its full signature, JSDoc documentation, inheritance, and source location. Use hoist-search-symbols first to find the symbol name.',
        inputSchema: z.object({
            name: z.string().describe('Exact symbol name (e.g. "GridModel", "Store", "HoistModel")'),
            filePath: z.string().optional()
                .describe('Source file path to disambiguate if multiple symbols share the same name')
        }),
        annotations: {
            readOnlyHint: true,
            destructiveHint: false,
            idempotentHint: true,
            openWorldHint: false
        }
    },
    async ({name, filePath}) => { ... }
);
```

Handler implementation:
1. Call `ensureInitialized()`
2. Call `getSymbolDetail(name, filePath)`
3. If null, return "Symbol 'name' not found. Use hoist-search-symbols to find available symbols."
4. Format as clean TypeScript-like output:
```
# GridModel (class)
Package: cmp/grid
File: cmp/grid/GridModel.ts
Exported: yes
Extends: HoistModel
Implements: SizingModeAware
Decorators: @managed

## Signature
export class GridModel extends HoistModel implements SizingModeAware {

## Documentation
Primary model for the Grid component. Manages columns, data, selection,
sorting, grouping, and filtering state.

Use hoist-get-members to see all properties and methods.
```

**Tool 3: hoist-get-members**

```typescript
server.registerTool(
    'hoist-get-members',
    {
        title: 'Get Hoist Class/Interface Members',
        description: 'List all properties and methods of a class or interface with their types, decorators, and documentation. Use hoist-search-symbols or hoist-get-symbol first to identify the target symbol.',
        inputSchema: z.object({
            name: z.string().describe('Class or interface name (e.g. "GridModel", "HoistModel")'),
            filePath: z.string().optional()
                .describe('Source file path to disambiguate if multiple symbols share the same name')
        }),
        annotations: {
            readOnlyHint: true,
            destructiveHint: false,
            idempotentHint: true,
            openWorldHint: false
        }
    },
    async ({name, filePath}) => { ... }
);
```

Handler implementation:
1. Call `ensureInitialized()`
2. Call `getMembers(name, filePath)`
3. If null, return appropriate error message (symbol not found, or not a class/interface)
4. Format members as grouped output:
```
# GridModel Members

## Properties (N)
- @observable columns: ColumnOrGroup[]
    Columns displayed in the grid.
- @bindable selectedIds: Set<string>
    Currently selected record IDs.
- store: Store
    Underlying data store.

## Methods (N)
- selectAsync(ids: string[]): Promise<void>
    Select records by ID.
- loadData(rawData: any[]): void
    Load raw data into the grid's store.

## Static Properties (N)
...

## Static Methods (N)
...
```

Include decorator annotations (prefixed with @) before member names. Include JSDoc description
on the line below if present. Skip empty sections.

**Formatting notes:**
- Use markdown-style headers (##) for sections -- LLMs parse these well
- Show decorator names as `@decoratorName` prefix on member lines
- Show types after the colon for properties, return types for methods
- Show parameters inline for methods: `methodName(param1: Type1, param2: Type2): ReturnType`
- Truncate very long type strings (>200 chars) with "..." to keep output scannable
- File paths should be relative to repo root for readability
  </action>
  <verify>
Run `npx tsc --noEmit -p mcp/tsconfig.json` -- should pass with zero errors.
  </verify>
  <done>
typescript.ts exports registerTsTools with three tools (hoist-search-symbols, hoist-get-symbol,
hoist-get-members) all using zod schemas, tool annotations, and readable text formatting.
Type-checks cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire TypeScript tools into MCP server</name>
  <files>mcp/server.ts</files>
  <action>
Update `mcp/server.ts` to import and call the TypeScript tools registration:

1. Add import: `import {registerTsTools} from './tools/typescript.js';`
2. Add registration call: `registerTsTools(server);` after the existing `registerDocTools(server);` line

The server entry point should now register both doc and TS tools:
```typescript
registerDocResources(server);
registerDocTools(server);
registerTsTools(server);
```

This is a minimal wiring change -- the same pattern used when doc tools were added in Phase 2.
  </action>
  <verify>
Run `npx tsc --noEmit -p mcp/tsconfig.json` -- should pass with zero errors.
Run `echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | npx tsx mcp/server.ts 2>/dev/null | head -c 500` to verify the new tools appear in the tools list (look for "hoist-search-symbols", "hoist-get-symbol", "hoist-get-members" in the JSON output). This may produce partial/raw JSON -- just confirm the tool names are present.
  </verify>
  <done>
server.ts imports and registers TypeScript tools. The MCP server exposes all six tools:
hoist-search-docs, hoist-list-docs, hoist-ping (from Phase 2), plus hoist-search-symbols,
hoist-get-symbol, hoist-get-members (new). Type-checks and serves tools via MCP protocol.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit -p mcp/tsconfig.json` passes with zero errors
2. All three new tools (hoist-search-symbols, hoist-get-symbol, hoist-get-members) appear in MCP tools list
3. Tools import from ts-registry.ts (not duplicating extraction logic)
4. Tools use zod schemas with .describe() for all parameters
5. Tools have readOnlyHint: true, idempotentHint: true annotations
6. server.ts calls registerTsTools(server) alongside existing doc registrations
7. Tool output is formatted text (not raw JSON dumps)
</verification>

<success_criteria>
The three TypeScript MCP tools are registered and accessible. An LLM connected via MCP can search
for symbols, retrieve detailed type information, and list class/interface members. The tools use
lazy initialization so server startup time is unaffected.
</success_criteria>

<output>
After completion, create `.planning/phases/03-typescript-extraction/03-02-SUMMARY.md`
</output>
