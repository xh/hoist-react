---
phase: 01-mcp-server-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - mcp/server.ts
  - mcp/tools/placeholder.ts
  - mcp/resources/placeholder.ts
  - bin/hoist-mcp.mjs
autonomous: false

must_haves:
  truths:
    - "Developer can run 'yarn hoist-mcp' and a local MCP server starts successfully"
    - "Claude Code can connect to the server via stdio and receive valid MCP protocol responses"
    - "Server registers a placeholder tool (hoist-ping) with Zod schema validation that returns a response"
    - "Server registers a placeholder resource (hoist://server-info) that returns server metadata"
    - "All server output goes to stderr only -- no stdout contamination of the JSON-RPC stream"
  artifacts:
    - path: "mcp/server.ts"
      provides: "MCP server entry point with McpServer + StdioServerTransport"
      contains: "StdioServerTransport"
    - path: "mcp/tools/placeholder.ts"
      provides: "Placeholder tool registration function"
      contains: "hoist-ping"
    - path: "mcp/resources/placeholder.ts"
      provides: "Placeholder resource registration function"
      contains: "server-info"
    - path: "bin/hoist-mcp.mjs"
      provides: "CLI launcher script with shebang"
      contains: "#!/usr/bin/env node"
  key_links:
    - from: "mcp/server.ts"
      to: "mcp/tools/placeholder.ts"
      via: "import and function call"
      pattern: "registerTools"
    - from: "mcp/server.ts"
      to: "mcp/resources/placeholder.ts"
      via: "import and function call"
      pattern: "registerResources"
    - from: "mcp/server.ts"
      to: "@modelcontextprotocol/sdk/server/stdio.js"
      via: "StdioServerTransport import and connect"
      pattern: "server\\.connect"
    - from: "bin/hoist-mcp.mjs"
      to: "mcp/server.ts"
      via: "tsx execution of server entry point"
      pattern: "mcp/server\\.ts"
---

<objective>
Implement the MCP server with placeholder tool and resource, create the CLI launcher, and verify end-to-end connectivity with an MCP client.

Purpose: Delivers the core Phase 1 outcome -- a working MCP server that communicates via stdio, registers tools/resources with Zod schemas, and can be started with a single command.
Output: Working MCP server at `mcp/server.ts`, placeholder tool/resource, CLI launcher at `bin/hoist-mcp.mjs`, verified stdio connectivity.
</objective>

<execution_context>
@/Users/amcclain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amcclain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-mcp-server-foundation/01-RESEARCH.md
@.planning/phases/01-mcp-server-foundation/01-01-SUMMARY.md
@package.json
@mcp/util/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create placeholder tool, placeholder resource, and server entry point</name>
  <files>mcp/tools/placeholder.ts, mcp/resources/placeholder.ts, mcp/server.ts</files>
  <action>
Create `mcp/tools/placeholder.ts` -- a function that registers placeholder tools on a given McpServer instance:

```typescript
import type {McpServer} from '@modelcontextprotocol/sdk/server/mcp.js';
import {z} from 'zod';

/** Register placeholder tools for Phase 1 connectivity testing. */
export function registerTools(server: McpServer) {
    server.registerTool(
        'hoist-ping',
        {
            title: 'Hoist Ping',
            description: 'Verify the Hoist MCP server is running and responsive',
            inputSchema: z.object({})
        },
        async () => ({
            content: [{type: 'text', text: 'Hoist MCP server is running.'}]
        })
    );
}
```

Use `server.registerTool()` (the full-form API with title/description), NOT the shorthand `server.tool()`. This follows the research recommendation for production code -- the metadata improves LLM tool discovery.

Create `mcp/resources/placeholder.ts` -- a function that registers placeholder resources:

```typescript
import type {McpServer} from '@modelcontextprotocol/sdk/server/mcp.js';

/** Register placeholder resources for Phase 1 connectivity testing. */
export function registerResources(server: McpServer) {
    server.resource(
        'server-info',
        'hoist://server-info',
        {
            title: 'Server Info',
            description: 'Hoist MCP server metadata and status',
            mimeType: 'application/json'
        },
        async (uri) => ({
            contents: [{
                uri: uri.href,
                text: JSON.stringify({
                    name: 'hoist-react',
                    version: '1.0.0',
                    status: 'running',
                    phase: 'foundation'
                }, null, 2)
            }]
        })
    );
}
```

Create `mcp/server.ts` -- the main entry point that creates the server, registers tools/resources, and connects via stdio:

```typescript
import {McpServer} from '@modelcontextprotocol/sdk/server/mcp.js';
import {StdioServerTransport} from '@modelcontextprotocol/sdk/server/stdio.js';
import {log} from './util/logger.js';
import {registerTools} from './tools/placeholder.js';
import {registerResources} from './resources/placeholder.js';

const server = new McpServer({
    name: 'hoist-react',
    version: '1.0.0'
});

registerTools(server);
registerResources(server);

const transport = new StdioServerTransport();
await server.connect(transport);

log.info('Server started, awaiting MCP client connection via stdio');
```

IMPORTANT notes on imports:
- Use `.js` extensions in relative imports (e.g., `'./util/logger.js'`). This is required by Node16 module resolution -- TypeScript resolves `.js` to `.ts` at compile time, and tsx handles it at runtime.
- Use the SDK's sub-path exports exactly as documented: `@modelcontextprotocol/sdk/server/mcp.js` and `@modelcontextprotocol/sdk/server/stdio.js`.
- NEVER use `console.log()` anywhere in MCP code. Use the `log` utility from `./util/logger.js` for all diagnostic output.
- The top-level `await` is fine -- tsx runs the file as an ES module.
  </action>
  <verify>
Type-check MCP code:
```bash
npx tsc --project mcp/tsconfig.json --noEmit
```
Should exit 0 with no errors.

Quick smoke test -- start the server and immediately send it a valid JSON-RPC initialize message, then check for a response:
```bash
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-06-18","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}' | timeout 5 npx tsx mcp/server.ts 2>/dev/null | head -1
```
Should output a JSON-RPC response containing `"result"` with server capabilities.
  </verify>
  <done>mcp/server.ts creates an McpServer, registers a hoist-ping tool and server-info resource, connects via StdioServerTransport, and logs startup to stderr. Server responds to MCP initialize messages with valid protocol responses.</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI launcher script</name>
  <files>bin/hoist-mcp.mjs</files>
  <action>
Create the `bin/` directory and `bin/hoist-mcp.mjs` -- a thin Node.js launcher script:

```javascript
#!/usr/bin/env node
//
// Hoist MCP Server launcher.
// Uses tsx to run the TypeScript server entry point directly.
//
import {execFileSync} from 'child_process';
import {fileURLToPath} from 'url';
import {dirname, resolve} from 'path';

const __dirname = dirname(fileURLToPath(import.meta.url));
const serverPath = resolve(__dirname, '..', 'mcp', 'server.ts');
const tsxPath = resolve(__dirname, '..', 'node_modules', '.bin', 'tsx');

try {
    execFileSync(tsxPath, [serverPath], {
        stdio: ['inherit', 'inherit', 'inherit'],
        env: {...process.env}
    });
} catch (e) {
    process.exit(e.status || 1);
}
```

After creating the file, make it executable:
```bash
chmod +x bin/hoist-mcp.mjs
```

This launcher:
- Has a shebang so it can run as `./bin/hoist-mcp.mjs` directly
- Resolves tsx and server.ts relative to its own location (works regardless of cwd)
- Passes through all stdio (stdin/stdout for JSON-RPC, stderr for logging)
- Passes through all environment variables (including HOIST_MCP_DEBUG)
- Exits with the server's exit code on failure
  </action>
  <verify>
Verify the launcher is executable and resolves paths correctly:
```bash
test -x bin/hoist-mcp.mjs && echo "executable: yes" || echo "executable: no"
```

Test the launcher starts the server (same initialize test as before, but via the bin script):
```bash
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-06-18","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}' | timeout 5 ./bin/hoist-mcp.mjs 2>/dev/null | head -1
```
Should output a JSON-RPC response with server capabilities (same as the direct tsx invocation).

Also verify `yarn hoist-mcp` works (will block waiting for input, so use timeout):
```bash
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-06-18","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}' | timeout 5 yarn --silent hoist-mcp 2>/dev/null | head -1
```
  </verify>
  <done>bin/hoist-mcp.mjs exists, is executable, and successfully launches the MCP server. Both `./bin/hoist-mcp.mjs` and `yarn hoist-mcp` start the server and respond to MCP initialize messages.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify MCP server connectivity with Claude Code</name>
  <files>none</files>
  <action>
Human verification checkpoint. Register the MCP server with Claude Code and test end-to-end connectivity. Claude should automate the registration command, then pause for the user to verify in a fresh session.

Register the server:
```bash
claude mcp add --transport stdio --scope project hoist-react -- npx tsx mcp/server.ts
```
  </action>
  <verify>User confirms Claude Code can connect and invoke hoist-ping tool and read server-info resource.</verify>
  <done>User has approved that the MCP server connects and responds correctly via Claude Code.</done>
  <what-built>
A complete MCP server for hoist-react with:
- `yarn hoist-mcp` command that starts the server via stdio
- A `hoist-ping` tool that responds with "Hoist MCP server is running."
- A `hoist://server-info` resource returning server metadata as JSON
- All logging to stderr only (no stdout contamination)
- Full bundle isolation (tsconfig exclusion, .npmignore, devDependencies)
  </what-built>
  <how-to-verify>
1. Register the MCP server with Claude Code (run from hoist-react root):
   ```bash
   claude mcp add --transport stdio --scope project hoist-react -- npx tsx mcp/server.ts
   ```

2. Start a new Claude Code session in the hoist-react directory.

3. Ask Claude to use the `hoist-ping` tool. It should respond with "Hoist MCP server is running."

4. Ask Claude to read the `hoist://server-info` resource. It should return JSON with name, version, status, and phase fields.

5. Check that no errors appeared during the interaction.
  </how-to-verify>
  <resume-signal>Type "approved" if the server connects and responds correctly, or describe any issues encountered.</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --project mcp/tsconfig.json --noEmit` exits 0 (type-check passes)
2. Initialize handshake works via stdin pipe (returns JSON-RPC response with capabilities)
3. `grep -rc 'console.log' mcp/` prints 0 (no stdout usage in MCP code)
4. `bin/hoist-mcp.mjs` is executable and launches the server
5. `yarn hoist-mcp` starts the server (via package.json scripts)
6. Human confirms Claude Code can connect and invoke hoist-ping tool
</verification>

<success_criteria>
- MCP server starts with `yarn hoist-mcp` and responds to MCP protocol messages
- hoist-ping tool returns "Hoist MCP server is running." when invoked
- hoist://server-info resource returns server metadata JSON
- No console.log() calls exist in any mcp/ file
- Server stderr shows "[hoist-mcp] Server started" log message
- Claude Code can connect via stdio and interact with the server
</success_criteria>

<output>
After completion, create `.planning/phases/01-mcp-server-foundation/01-02-SUMMARY.md`
</output>
