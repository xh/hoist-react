# MCP Server

## Overview

The Hoist MCP (Model Context Protocol) server gives AI coding assistants structured access to
hoist-react's documentation, TypeScript type information, and code generation prompts. It runs as a
local stdio-based server that any MCP-compatible client (e.g. Claude Code) can connect to.

**What it provides:**

- **Documentation tools** -- search and browse all hoist-react READMEs and concept docs
- **TypeScript tools** -- search symbols, inspect types, and list class/interface members
- **Developer prompts** -- structured starting points for creating grids, forms, and tab containers
- **Documentation resources** -- direct access to any doc by URI

**Audience:** AI assistants working with hoist-react codebases, and developers configuring those
assistants. The server is not used at runtime by applications.

**Why embed it:** Unlike external documentation services, this MCP server reads directly from the
framework source -- no indexing service, no API key, no sync lag. Documentation, type information,
and source code are always consistent with the developer's checked-out version of hoist-react.

**Authorship note:** The MCP server sub-project (~3,000 lines across 13 TypeScript files) was
entirely generated by Claude Code, making it the first AI-authored component in hoist-react. The MCP server was developed across four
phases (foundation, documentation serving, TypeScript extraction, developer prompts), with each
phase reviewed and validated by a human developer.

## Architecture

### Directory Structure

```
mcp/
├── server.ts                  # Entry point -- creates McpServer, registers all capabilities
├── package.json               # ES module config (type: "module")
├── tsconfig.json              # TypeScript config (target: ES2022, module: Node16)
├── data/
│   ├── doc-registry.ts        # Hardcoded documentation inventory with metadata and search
│   └── ts-registry.ts         # Lazy ts-morph symbol index with on-demand type extraction
├── resources/
│   └── docs.ts                # MCP resource registrations (static + template)
├── tools/
│   ├── docs.ts                # Documentation tools (search, list, ping)
│   └── typescript.ts          # TypeScript tools (search-symbols, get-symbol, get-members)
├── prompts/
│   ├── index.ts               # Prompt registration orchestrator
│   ├── grid.ts                # Grid creation prompt builder
│   ├── form.ts                # Form creation prompt builder
│   ├── tabs.ts                # Tab container prompt builder
│   └── util.ts                # Shared utilities (doc loading, section extraction, conventions)
└── util/
    ├── logger.ts              # Stderr-only logging (protects stdio JSON-RPC)
    └── paths.ts               # Repo root resolution and path traversal safety
```

### Data Flow

```
MCP Client (e.g. Claude Code)
    │
    │  JSON-RPC over stdio
    │
    ▼
server.ts (McpServer)
    │
    ├── resources/docs.ts ──► data/doc-registry.ts ──► README files on disk
    ├── tools/docs.ts     ──► data/doc-registry.ts ──► keyword search + snippets
    ├── tools/typescript.ts ─► data/ts-registry.ts ──► ts-morph AST parsing
    └── prompts/*.ts ──────► doc-registry + ts-registry ──► composed markdown
```

### Design Decisions

**Bundle isolation via import chains.** hoist-react ships as raw TypeScript source -- applications
compile it via webpack during their own build. Webpack only processes files reachable via import
chains from app entry points. As long as no browser-targeted hoist code imports from `mcp/`, the
MCP server's Node-only dependencies (`@modelcontextprotocol/sdk`, `ts-morph`, etc.) will never
enter application bundles. The separate `tsconfig.json` provides an additional safety net at the
type-checking level, and all MCP dependencies are `devDependencies` in the root `package.json`.

**Hardcoded doc registry over filesystem scanning.** The doc registry (`data/doc-registry.ts`)
defines each documentation entry in code rather than discovering files on disk. This was chosen
because the documentation corpus is bounded and well-known (~30 files), and each entry needs
curated metadata (title, description, category, search keywords) that cannot be reliably derived
from filenames alone. The metadata is aligned with the `docs/README.md` index tables. The
tradeoff is manual maintenance -- see [Maintaining the MCP Server](#maintaining-the-mcp-server).

**Lazy TypeScript initialization with eager indexing.** Parsing hoist-react's ~700 TypeScript files
with ts-morph is expensive. The `Project` is created lazily on first TypeScript tool invocation
(not at server startup), keeping cold start fast. Once created, a lightweight symbol index
(name-to-location map) is built eagerly using AST-level methods (`getClasses()`,
`getInterfaces()`, etc.) rather than full type resolution. Detailed symbol information (signatures,
JSDoc, members) is extracted on-demand from individual source files.

**Resources for nouns, tools for verbs.** Following MCP protocol design guidance: resources serve
passive, addressable content (individual docs by URI), while tools handle dynamic computation
(keyword search across the corpus, symbol lookup). This maps naturally -- a document is a resource
you read; a search is a tool you invoke.

**Prompts compose live content.** Each prompt builder loads documentation excerpts and type
signatures from the registries at invocation time rather than embedding hardcoded content. This
means prompts stay current as documentation and source code evolve, with no separate maintenance
burden. The tradeoff is that prompts reference specific README section headers and class member
names by string -- if those are renamed, the prompt degrades gracefully (omitting the missing
section) rather than failing.

**Stdio transport with stderr logging discipline.** Stdout corruption from stray `console.log()`
calls is the most common bug in MCP server implementations. A single log statement corrupts the
JSON-RPC stream, manifesting as mysterious protocol errors. The custom logger in `util/logger.ts`
writes exclusively to stderr.

## Setup

### Prerequisites

- Node.js 18+
- `tsx` available (included in hoist-react's devDependencies)
- A checked-out hoist-react repository

### Starting the Server

**Method 1: `.mcp.json` (recommended for Claude Code)**

The repository includes a `.mcp.json` file that Claude Code reads automatically:

```json
{
  "mcpServers": {
    "hoist-react": {
      "type": "stdio",
      "command": "npx",
      "args": ["tsx", "mcp/server.ts"],
      "env": {}
    }
  }
}
```

No manual setup is needed -- Claude Code discovers and starts the server when you open a session
in the hoist-react directory.

**Method 2: yarn script**

```bash
yarn hoist-mcp
```

**Method 3: npx (from installed package)**

```bash
npx hoist-mcp
```

### Verification

After starting, call the `hoist-ping` tool to verify connectivity. In Claude Code, the MCP tools
appear automatically in the tool list (e.g. `mcp__hoist-react__hoist-ping`).

### Debug Logging

Set the `HOIST_MCP_DEBUG` environment variable to enable verbose debug output on stderr:

```json
{
  "mcpServers": {
    "hoist-react": {
      "type": "stdio",
      "command": "npx",
      "args": ["tsx", "mcp/server.ts"],
      "env": {"HOIST_MCP_DEBUG": "1"}
    }
  }
}
```

## Tools Reference

### Documentation Tools

#### `hoist-search-docs`

Search across all hoist-react documentation by keyword. Returns matching documents with context
snippets showing where terms appear.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `query` | string | Yes | Search keywords (e.g. `"grid column sorting"`) |
| `category` | enum | No | Filter: `package`, `concept`, `devops`, `conventions`, `all` (default) |
| `limit` | number | No | Max results, 1-20. Default: 10 |

**Example output:**
```
Found 3 results for "grid sorting":

1. [Grid Component] (id: cmp/grid, category: package)
   Primary data grid built on ag-Grid.
   Matches: 6 | Snippets:
   - L45: GridModel manages sorting, grouping, selection...
```

#### `hoist-list-docs`

List all available documentation with descriptions, grouped by category.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `category` | enum | No | Filter: `package`, `concept`, `devops`, `conventions`, `all` (default) |

#### `hoist-ping`

Verify the MCP server is running and responsive. Takes no parameters.

### TypeScript Tools

#### `hoist-search-symbols`

Search for TypeScript classes, interfaces, types, and functions by name.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `query` | string | Yes | Symbol name or partial name (e.g. `"GridModel"`, `"Store"`) |
| `kind` | enum | No | Filter: `class`, `interface`, `type`, `function`, `const`, `enum` |
| `exported` | boolean | No | Exported symbols only. Default: `true` |
| `limit` | number | No | Max results, 1-50. Default: 20 |

**Note:** The TypeScript index is built lazily on first invocation (typically under 5 seconds).
Subsequent calls are fast.

#### `hoist-get-symbol`

Get detailed type information for a specific symbol: full signature, JSDoc, inheritance, decorators,
and source location. Use `hoist-search-symbols` first to find the exact name.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | string | Yes | Exact symbol name (e.g. `"GridModel"`) |
| `filePath` | string | No | Source file path to disambiguate duplicate names |

#### `hoist-get-members`

List all properties and methods of a class or interface with types, decorators, and JSDoc.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | string | Yes | Class or interface name (e.g. `"GridModel"`) |
| `filePath` | string | No | Source file path to disambiguate duplicate names |

**Example output (abbreviated):**
```
# GridModel Members

## Properties (42)
- @observable columns: ColumnOrGroup[]
    Columns displayed in the grid.
- @managed store: Store
    Data source for the grid.

## Methods (18)
- loadData(rawData: StoreRecord[]): void
    Load data into the grid's store.
```

## Resources and Prompts

### Resources

Resources provide direct read access to documentation files via URI.

| Name | URI | Content |
|------|-----|---------|
| `doc-index` | `hoist://docs/index` | `docs/README.md` -- the primary documentation catalog |
| `conventions` | `hoist://docs/conventions` | `AGENTS.md` -- coding conventions and patterns |
| `hoist-doc` | `hoist://docs/{+docId}` | Any document by ID (e.g. `hoist://docs/cmp/grid`) |

The `hoist-doc` template uses RFC 6570 reserved expansion (`{+docId}`) so slashes in doc IDs
(e.g. `cmp/grid`) are preserved rather than percent-encoded.

**Discovering available documents:** The `hoist-doc` resource supports `list` and `complete`
operations. MCP clients can enumerate all available doc IDs or get tab-completion suggestions.

### Prompts

Prompts compose documentation excerpts, type signatures, coding conventions, and code templates
into structured starting points for common development tasks. In Claude Code, they surface as
available prompts (e.g. `/mcp__hoist-react__create-grid`).

#### `create-grid`

Generate a Hoist grid panel with model, columns, data loading, and component.

| Argument | Type | Description |
|----------|------|-------------|
| `dataFields` | string | Comma-separated field names (e.g. `"name,value,date"`) |
| `features` | string | Features to include: `sorting`, `grouping`, `selection`, `export`, `filtering`, `treeMode` |

**Produces:** A composed markdown guide containing grid documentation excerpts, GridModel/Column
type signatures, Hoist conventions, an adaptive code template (Model + Component files), and
next-step tool suggestions.

#### `create-form`

Generate a Hoist form with model, field definitions, validation, and component.

| Argument | Type | Description |
|----------|------|-------------|
| `fields` | string | Comma-separated field names (e.g. `"firstName,lastName,email"`) |
| `validation` | string | Include validation examples: `"true"` or `"false"` |

**Produces:** A composed markdown guide with form documentation excerpts (FormModel, FieldModel,
input components), type signatures, an adaptive code template with smart input type detection,
optional validation rules, and next-step tool suggestions.

#### `create-tab-container`

Generate a Hoist tabbed interface with model configuration and content panels.

| Argument | Type | Description |
|----------|------|-------------|
| `tabs` | string | Comma-separated tab names (e.g. `"overview,details,history"`) |
| `routing` | string | Include route integration: `"true"` or `"false"` |

**Produces:** A composed markdown guide with tab documentation excerpts (TabContainerModel,
TabModel, refresh strategies), type signatures, an adaptive code template with content panel stubs,
optional routing configuration, and next-step tool suggestions.

## Maintaining the MCP Server

The MCP server contains several hardcoded data points that must be kept in sync with the hoist-react
codebase. This section catalogs each maintenance point, its location, and when updates are needed.

### Doc Registry Entries

**File:** `mcp/data/doc-registry.ts` (function `getRawEntries()`)

The doc registry is the single source of truth for all documentation that the MCP server can search
and serve. Each entry specifies an `id`, `title`, `file` path, `category`, `description`, and
`keywords` array.

**When to update:**
- A new README or concept doc is added to hoist-react
- A documentation file is renamed or moved
- A documentation file is removed
- The description or key topics for a doc change significantly

**How to update:** Add, modify, or remove the corresponding `RawEntry` object in the
`getRawEntries()` function. The `file` path is relative to the repo root. The `keywords` string
is comma-separated and split automatically.

### Top-Level Packages Array

**File:** `mcp/data/ts-registry.ts` (constant `TOP_LEVEL_PACKAGES`)

This array lists all top-level directories that contain TypeScript source files. It is used to
derive the `sourcePackage` for each symbol in the index (e.g. a file at `cmp/grid/GridModel.ts`
maps to package `cmp/grid`).

**When to update:**
- A new top-level package directory is added to hoist-react
- A top-level package directory is renamed or removed

**Current value:**
```typescript
const TOP_LEVEL_PACKAGES = [
    'core', 'data', 'svc', 'cmp', 'desktop', 'mobile',
    'format', 'appcontainer', 'utils', 'promise', 'mobx',
    'public', 'static', 'admin', 'inspector', 'icon'
];
```

### Prompt Documentation Section References

**Files:** `mcp/prompts/grid.ts`, `mcp/prompts/form.ts`, `mcp/prompts/tabs.ts`

Each prompt builder calls `extractSection(doc, 'Section Name')` to pull specific sections from
README files. These calls reference section headers by exact name. If a referenced section header
is renamed or removed in the source README, the extraction will silently return an empty string
(the prompt degrades gracefully but loses content).

**Current references:**

| Prompt | Source Doc | Sections Referenced |
|--------|-----------|---------------------|
| `grid.ts` | `cmp/grid` | Common Usage Patterns, Column Properties Reference, Configuration Pattern |
| `form.ts` | `cmp/form` | FormModel, FieldModel, Form Component, Common Patterns, Common Pitfalls |
| `form.ts` | `cmp/input` | Overview |
| `tabs.ts` | `cmp/tab` | TabContainerModel, TabModel, Refresh Integration, Common Patterns, Common Pitfalls |

**When to update:** When renaming or removing any of the section headers listed above in the
corresponding README file.

### Prompt Symbol and Member References

**Files:** `mcp/prompts/grid.ts`, `mcp/prompts/form.ts`, `mcp/prompts/tabs.ts`

Each prompt builder calls `formatSymbolSummary('ClassName')` and
`formatKeyMembers('ClassName', ['member1', 'member2', ...])` to include type information. If a
referenced class is renamed or a member is removed, the output will include a "not found" placeholder.

**Current references:**

| Prompt | Symbols | Key Members |
|--------|---------|-------------|
| `grid.ts` | GridModel, Column | store, columns, sortBy, selModel, groupBy, emptyText, onRowDoubleClicked |
| `form.ts` | FormModel, FieldModel | fields, values, isValid, isDirty, init, reset, validateAsync (FormModel); value, displayName, rules, isRequired, isValid, isDirty (FieldModel) |
| `tabs.ts` | TabContainerModel, TabModel | tabs, activeTabId, route, TabModel (TabContainerModel); id, title, content, renderMode, refreshMode (TabModel) |

**When to update:** When renaming any of the classes or members listed above.

### Conventions Block

**File:** `mcp/prompts/util.ts` (function `hoistConventionsSection()`)

A static string block of key Hoist coding conventions included in every prompt. This ensures
LLM-generated code follows Hoist idioms (element factories, `@managed`, `makeObservable`, etc.).

**When to update:** When major architectural patterns change -- e.g. if the element factory pattern
were replaced, or if `makeObservable` were no longer required.

### Summary: Maintenance Checklist

| Change | Files to Update |
|--------|----------------|
| Add/rename/remove a documentation file | `mcp/data/doc-registry.ts`, `docs/README.md` |
| Add/rename/remove a top-level package | `mcp/data/ts-registry.ts` |
| Rename a section header in a component README | Check `mcp/prompts/grid.ts`, `form.ts`, `tabs.ts` |
| Rename a key class or remove a key member | Check `mcp/prompts/grid.ts`, `form.ts`, `tabs.ts` |
| Change a fundamental coding convention | `mcp/prompts/util.ts` |

## Extending the MCP Server

### Adding a New Tool

Register tools in `tools/docs.ts` or `tools/typescript.ts` (or create a new file and wire it
into `server.ts`):

```typescript
// In tools/my-tools.ts
import type {McpServer} from '@modelcontextprotocol/sdk/server/mcp.js';
import {z} from 'zod';

export function registerMyTools(server: McpServer): void {
    server.registerTool(
        'hoist-my-tool',                      // Name (prefix with hoist-)
        {
            title: 'My Tool Title',
            description: 'What the tool does',
            inputSchema: z.object({
                param: z.string().describe('Parameter description')
            }),
            annotations: {
                readOnlyHint: true,
                destructiveHint: false,
                idempotentHint: true,
                openWorldHint: false
            }
        },
        async ({param}) => ({
            content: [{type: 'text' as const, text: `Result for ${param}`}]
        })
    );
}
```

Then in `server.ts`:

```typescript
import {registerMyTools} from './tools/my-tools.js';
// ...
registerMyTools(server);
```

### Adding a New Resource

Add resource registrations in `resources/docs.ts` or create a new resource file:

```typescript
server.registerResource(
    'my-resource',                             // Registration name
    'hoist://my-resource/path',                // URI
    {
        title: 'My Resource',
        description: 'What it provides',
        mimeType: 'text/markdown'
    },
    async uri => ({
        contents: [{uri: uri.href, text: 'Content here', mimeType: 'text/markdown'}]
    })
);
```

### Adding a New Prompt

Create a new prompt builder file in `prompts/` following the pattern of `grid.ts`:

```typescript
// In prompts/my-prompt.ts
import type {GetPromptResult} from '@modelcontextprotocol/sdk/types.js';
import {loadDoc, extractSection, hoistConventionsSection} from './util.js';

export async function buildMyPrompt(args: {
    someArg?: string;
}): Promise<GetPromptResult> {
    const doc = loadDoc('relevant-doc-id');
    const section = extractSection(doc, 'Relevant Section');

    return {
        description: 'What this prompt produces',
        messages: [{
            role: 'user',
            content: {type: 'text', text: `# My Prompt\n\n${hoistConventionsSection()}\n\n${section}`}
        }]
    };
}
```

Then register it in `prompts/index.ts`:

```typescript
import {buildMyPrompt} from './my-prompt.js';
// ...
server.registerPrompt('my-prompt', {
    title: 'My Prompt Title',
    description: 'What it does',
    argsSchema: {someArg: z.string().optional().describe('Argument description')}
}, async ({someArg}) => buildMyPrompt({someArg}));
```

### Adding a Doc Registry Entry

Add a new `RawEntry` to the `getRawEntries()` function in `mcp/data/doc-registry.ts`:

```typescript
{
    id: 'my-package',
    title: 'My Package',
    file: 'my-package/README.md',        // Relative to repo root
    category: 'package',
    packageName: 'my-package',
    description: 'What this package does.',
    keywords: splitKeywords('keyword1, keyword2, keyword3')
},
```

**Categories:** `package` (package READMEs), `concept` (cross-cutting docs), `devops` (build/deploy
docs), `conventions` (AGENTS.md), `index` (docs/README.md).

## Common Pitfalls

### Stdout Corruption

All logging **must** go to stderr, never stdout. The MCP protocol uses stdout exclusively for
JSON-RPC messages. Use the `log` object from `util/logger.ts` -- never `console.log()`.

```typescript
// ✅ Do: Use the logger
import {log} from '../util/logger.js';
log.info('Server started');

// ❌ Don't: Use console.log (corrupts JSON-RPC on stdout)
console.log('Server started');
```

### Path Traversal

The `resolveDocPath()` utility in `util/paths.ts` validates that resolved paths stay within the
repository root. It rejects paths containing `..` segments. Always use this function when resolving
file paths from external input.

### Registry Sync

The doc registry is hardcoded, not filesystem-scanned. When documentation files are added or
removed, the registry must be updated manually. If a file referenced by a registry entry is missing
on disk, the entry is logged as a warning and skipped at startup -- it does not cause a crash.

See [Maintaining the MCP Server](#maintaining-the-mcp-server) for the full maintenance checklist.

### Tool Naming Conventions

Documentation and TypeScript tools are prefixed with `hoist-` (e.g. `hoist-search-docs`,
`hoist-get-symbol`). Prompts are **not** prefixed with `hoist-` because the MCP server name
(`hoist-react`) already provides namespace context -- the fully qualified prompt name becomes
`mcp__hoist-react__create-grid`.
