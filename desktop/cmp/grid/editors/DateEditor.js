/*
 * This file belongs to Hoist, an application development toolkit
 * developed by Extremely Heavy Industries (www.xh.io | info@xh.io)
 *
 * Copyright Â© 2021 Extremely Heavy Industries Inc.
 */
import {hoistCmp} from '@xh/hoist/core';
import {dateInput} from '@xh/hoist/desktop/cmp/input';
import {getBoundingClientRect, getOffsetParent, getPopperOffsets, getOffsetRectRelativeToArbitraryNode}  from 'popper.js/dist/popper-utils';
import {warnIf} from '@xh/hoist/utils/js';
import {useInlineEditorModel} from './impl/InlineEditorModel';
import {EditorPropTypes} from './EditorPropTypes';
import './Editors.scss';

export const [DateEditor, dateEditor] = hoistCmp.withFactory({
    displayName: 'DateEditor',
    className: 'xh-date-editor',
    model: false,
    memo: false,
    observer: false,
    render(props, ref) {
        // We need to render the day picker popover inside the grid viewport in order for
        // `stopEditingWhenCellsLoseFocus` to work properly - otherwise the day picker becomes
        // unusable due to the grid losing focus and stopping editing when clicking inside picker
        const portalContainer = props.gridModel.agApi.gridBodyComp?.eBodyViewport;
        console.log(props.gridModel.agApi.gridBodyComp?.eBodyViewport);
        console.log(props.gridModel.agApi, props.gridModel.agApi.gridBodyComp);
        warnIf(
            !portalContainer,
            'Could not find the grid body viewport for rendering DateEditor picker popover.'
        );

        props = {
            ...props,
            inputProps: {
                rightElement: null,

                enablePicker: !!portalContainer,
                showPickerOnFocus: !!portalContainer,
                portalContainer,
                popoverBoundary: 'scrollParent',
                popoverMofifiers: {
                    computeStyle: {
                        enabled: true,
                        fn: (data, options) => computeStyleInAgGrid(data, options, portalContainer),
                        order: 850
                    },
                    flip: {enabled: false},
                    keepTogether: {enabled: false},
                    preventOverflow: {enabled: false}
                },
                ...props.inputProps
            }
        };
        return useInlineEditorModel(dateInput, props, ref);
    }
});
DateEditor.propTypes = {
    ...EditorPropTypes
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyleInAgGrid(data, options, portalContainer) {
    const {x, y} = options,
        sideA = x === 'bottom' ? 'top' : 'bottom',
        sideB = y === 'right' ? 'left' : 'right',
        styles = {position: data.offsets.popper.position},
        inputEl = data.instance.reference,
        offsetParent = getOffsetParent(data.instance.popper),
        offsetParentRect = getBoundingClientRect(offsetParent),
        rowContainer = inputEl.closest('[ref=eContainer]');

    if (!rowContainer) return data;

    const hScrollPort = rowContainer.parentNode,
        hScroll = hScrollPort.scrollLeft,
        vScroll = portalContainer.scrollTop,
        vpHeight = portalContainer.offsetHeight;
        
    // 1: recalc reference offsets with ag-grid container
    data.offsets.reference = getOffsetRectRelativeToArbitraryNode(inputEl, rowContainer, false);
    // 2: must recalc popper offets with new reference offsets
    data.offsets.popper =  getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement);

    const {top, right, bottom, left, height} = data.offsets.popper,
        flipToAbove = top - vScroll + height > vpHeight,
        inputElHeight = data.offsets.reference.height;

    let trLeft = void 0,
        trTop = void 0;
    if (sideA === 'bottom') {
        trTop = -offsetParentRect.height + bottom;
    } else {
        trTop = top - (flipToAbove ? inputElHeight + height : 0);
    }
    if (sideB === 'right') {
        trLeft = -offsetParentRect.width + right;
    } else {
        trLeft = left - hScroll;
    }

    styles.transform = 'translate3d(' + trLeft + 'px, ' + trTop + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';

    const attributes = {
        'x-placement': data.placement
    };

    data.attributes = Object.assign({}, attributes, data.attributes);
    data.styles = Object.assign({}, styles, data.styles);
    data.arrowStyles = Object.assign({}, data.offsets.arrow, data.arrowStyles);

    return data;
}