/*
 * This file belongs to Hoist, an application development toolkit
 * developed by Extremely Heavy Industries (www.xh.io | info@xh.io)
 *
 * Copyright Â© 2021 Extremely Heavy Industries Inc.
 */
import {hoistCmp} from '@xh/hoist/core';
import {dateInput} from '@xh/hoist/desktop/cmp/input';
import {getBoundingClientRect, getOffsetParent, getPopperOffsets, getOffsetRectRelativeToArbitraryNode}  from 'popper.js/dist/popper-utils';
import {warnIf} from '@xh/hoist/utils/js';
import {useInlineEditorModel} from './impl/InlineEditorModel';
import {EditorPropTypes} from './EditorPropTypes';
import './Editors.scss';

export const [DateEditor, dateEditor] = hoistCmp.withFactory({
    displayName: 'DateEditor',
    className: 'xh-date-editor',
    model: false,
    memo: false,
    observer: false,
    render(props, ref) {
        // We need to render the day picker popover inside the grid viewport in order for
        // `stopEditingWhenCellsLoseFocus` to work properly - otherwise the day picker becomes
        // unusable due to the grid losing focus and stopping editing when clicking inside picker
        const portalContainer = props.gridModel.agApi.gridBodyComp?.eBodyViewport;
        console.log(props.gridModel.agApi.gridBodyComp?.eBodyViewport);
        console.log(props.gridModel.agApi, props.gridModel.agApi.gridBodyComp);
        warnIf(
            !portalContainer,
            'Could not find the grid body viewport for rendering DateEditor picker popover.'
        );

        props = {
            ...props,
            inputProps: {
                rightElement: null,

                enablePicker: !!portalContainer,
                showPickerOnFocus: !!portalContainer,
                portalContainer,
                popoverBoundary: 'scrollParent',
                // popoverBoundary: props.gridModel.agApi.gridBodyComp?.eBodyViewport, // props.gridModel.agApi.gridBodyComp.getFocusableElement(),//portalContainer.children[1],
                // see https://github.com/palantir/blueprint/blob/d3b72d4d81efa89724567a907b879d0b428c080d/packages/core/src/components/popover/popover.tsx
                // for example of blueprintjs modifiers
                popoverMofifiers: {
                    computeStyle: {
                        enabled: true,
                        fn: computeStyleInAgGrid,
                        order: 850
                    }
                },
                ...props.inputProps
            }
        };
        return useInlineEditorModel(dateInput, props, ref);
    }
});
DateEditor.propTypes = {
    ...EditorPropTypes
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyleInAgGrid(data, options) {
    const {x, y} = options,
        sideA = x === 'bottom' ? 'top' : 'bottom',
        sideB = y === 'right' ? 'left' : 'right',
        {popper} = data.offsets;

    data.offsets.reference = getReferenceOffset(data.instance.reference);
    data.offsets.popper =  getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement);

    const offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    const styles = {
        position: popper.position
    };

    var roundedPopperOffsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);


    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
        top = -offsetParentRect.height + roundedPopperOffsets.bottom;
    } else {
        top = roundedPopperOffsets.top;
    }
    if (sideB === 'right') {
        left = -offsetParentRect.width + roundedPopperOffsets.right;
    } else {
        left = roundedPopperOffsets.left;
    }

    styles.transform = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';


    // Attributes
    var attributes = {
        'x-placement': data.placement
    };

    // Update `data` attributes, styles and arrowStyles
    data.attributes = Object.assign({}, attributes, data.attributes);
    data.styles = Object.assign({}, styles, data.styles);
    data.arrowStyles = Object.assign({}, data.offsets.arrow, data.arrowStyles);

    return data;
}

function getReferenceOffset(reference) {
    const parent = reference.closest('[ref=eViewport]');
    return getOffsetRectRelativeToArbitraryNode(reference, parent, false);
}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;
  
    var noRound = function noRound(v) {
        return v;
    };
  
    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
  
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    console.log(popper.top);
    return {
        left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
        top: verticalToInteger(popper.top),
        bottom: verticalToInteger(popper.bottom),
        right: horizontalToInteger(popper.right)
    };
}


const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof window.navigator !== 'undefined',
    isFirefox = isBrowser && /Firefox/i.test(window.navigator.userAgent);
  