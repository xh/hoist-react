/*
 * This file belongs to Hoist, an application development toolkit
 * developed by Extremely Heavy Industries (www.xh.io | info@xh.io)
 *
 * Copyright Â© 2022 Extremely Heavy Industries Inc.
 */
import {castArray, isArray, isNil, isPlainObject} from 'lodash';
import {createElement, ComponentClass, FunctionComponent, isValidElement, ReactNode, ReactElement} from 'react';
import {HoistProps} from './';


/**
 * Alternative format for specifying React Elements in render functions. This method is designed to
 * provide a well-formatted, declarative, native javascript approach to configuring Elements and
 * their children. It serves as an alternative to JSX and is especially useful for code-heavy
 * element trees. (For element trees with a significant amount of hypertext, JSX could be a better
 * choice.)
 *
 * The core enhancement to this format over jsx is it expects child elements and props to be
 * specified in a single bundle, with children placed within an `item` or `items` key. This allows
 * developers to write declarative, multi-level element trees in a concise yet highly-readable
 * style.
 *
 * This format is largely just a thin-wrapper over `React.createChildren`. A notable exception to
 * this is the minor-but-useful support for an `omit` property, which allows element
 * subtrees to be declaratively excluded from rendering if a given condition is met.
 *
 * Also Note that if a React Component has its own property of `item`, `items`, or `omit`, the
 * property must be specified with a `$` prefix (e.g. `$item`) to avoid conflicting with this API.
 *
 * See {@see elemFactory} and {@see ElemFactory} for a way to create factory functions that
 * easily consume this format and can be used by render functions. These factory functions are
 * automatically generated by {@see hoistCmp} for Hoist Components.
 *
 * {@see elem} for a generic function that will consume this format as well.
 */
export type ElemSpec<P> = P & {

    /** Child Element(s). Equivalent provided as Rest Arguments to React.createElement.*/
    items?: ReactNode|ReactNode[];

    /**  Equivalent to `items`, offered for code clarity when only one child is needed. */
    item?: ReactNode|ReactNode[];

    /** True to exclude the Element. */
    omit?: boolean
}


/**
 * A factory function that can create a ReactElement using native JS (i.e. not JSX).
 *
 * One critical aspect of this function is that its arguments may be *either* a single
 * ElementSpec or either an array or rest arguments representing just the children to be
 * passed to the new Element.  This latter case is fully equivalent to specifying `{items: [...]}`
 * and is useful when no attributes need to be applied directly to the Element.
 */
export type ElemFactory<P=HoistProps> =
    ((arg: ElemSpec<P>|ReactNode|ReactNode[]) => ReactElement<P>) &
    ((...args: ReactNode[]) => ReactElement<P>);


/**
 * Create a React Element from a Component type and an ElementSpec
 *
 * @param type - React Component or string representing an HTML element.
 * @param spec - element spec.
 */
export function elem<P=HoistProps>(
    type: ComponentClass<P>|FunctionComponent<P>|string,
    spec: ElemSpec<P>
): ReactElement<P> {
    const {omit, item, items, ...props} = spec;

    // 1) Convenience omission syntax.
    if (omit) return null;

    // 2) Read children from item[s] config.
    const itemConfig = item ?? items,
        children = (isNil(itemConfig) ? [] : castArray(itemConfig));

    // 3) Recapture API props that needed '$' prefix to avoid conflicts.
    ['$omit', '$item', '$items'].forEach(key => {
        if (props.hasOwnProperty(key)) {
            props[key.substring(1)] = props[key];
            delete props[key];
        }
    });

    return createElement(type, props as P, ...children);
}

/**
 * Create an ElementFactory for a specific Component type.
 *
 * This is a 'curried' version of the raw elem() method.
 *
 * Note that it is not typically necessary to call this function directly when defining a
 * HoistComponent -- `hoistCmp.withFactory` will generate and return the factory for you.
 * Use this function for generating factories for Components provided by external APIs.
 */
export function elemFactory<P=HoistProps>(type: FunctionComponent<P>|ComponentClass<P>|string): ElemFactory<P> {
    const ret = function(...args) {
        return elem(type, normalizeArgs(args));
    };
    ret.isElemFactory = true;
    return ret;
}


//------------------------
// Implementation
//------------------------
function normalizeArgs(args) {
    const len = args.length;
    if (len === 0) return {};
    if (len === 1) {
        const arg = args[0];
        if (isPlainObject(arg) && !isValidElement(arg)) return arg;
        if (isArray(arg)) return {items: arg};
    }
    // Assume > 1 args or single, non-config, non-array args are children.
    return {items: args};
}

